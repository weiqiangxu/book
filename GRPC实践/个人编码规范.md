# 个人编码规范


### 代码细节

1. 枚举值注释必须完善

2. 禁止出现硬编码

3. 有基本的单元测试验证（尽量使用断言而不是手动log人工判定单测是否通过）

4. 接口粒度应该细小、接口依赖应该明确、接口入参出参应该明确，对象化，最好可以做到依赖抽象而不是直接依赖具体的实现

5. 禁止在接口之中有隐藏的依赖条件（入参之中没有的参数比如环境变量，入参应该是决定输出的唯一条件）

6. 接口颗粒度要小一些（入参、出参尽可能简化易读），如果逻辑过于复杂应该对象化拆分，确保大接口拆出的小接口都走单元测试

7. 禁止IDE右侧出现notice黄色告警（单词拼写错误、命名不规范、公有方法没注释等）

8. 所有的指针访问都需要判定是否为nil

9. 所有的数组访问都需要判定length防止数组越界

10. 所有的除数都要判定被除数不是0

11. 关于同步转异步

```
如果是接口响应不强依赖执行结果的，比如用户关注频道后发送欢迎语
关注成功后异步发送欢迎语即可，不能阻塞主要流程，因为用户端不强依赖欢迎语

这个做toc的应用都懂，用户体验是第一位
```

12. 包命名规范

13. 禁止滥用init，个人建议整个项目不应该有init，main函数也是唯一的执行入口

14. 禁止滥用全局变量，应该保证依赖的关系足够清晰明了

15. 模块依赖管理，包与包之间的依赖关系清晰(按功能分块按业务水平分层按数据垂直分层，每一层之间尽可能解耦)

```
三层架构、领域驱动模型等都是追求分层，数据对象模型每一层之间都是解耦的
比如vo(view object视图)和持久化层对象po(数据库映射对象)
肯定是转换过的，而不是直接将po往http对外接口抛
```


16. 模块依赖管理，包的依赖应当尽可能是外部手动注入内部(选项模式注入私有属性) 而不是胡乱互相引用，比如user.service不能直接内部func进行new school.service 必须通过外部注入私有属性，这一点对于包依赖管理、各个分层解耦合很重要，也有利于单元测试覆盖

```
# 选项模式注入（不了解的自行百度啥是选项模式，在Elastic客户端或者其他的开源包都有用到）
type A struct {
    db *mysql.DB
    redis *redis
}

func (a *A)Get() {
    a.db.find()
}
```

```
# 对单元测试不友好并且service A的依赖不够直观
type A struct {
}

func (a *A)Get() {
    // 全局包变量直接用
    global.db.find()
    // 直接new一个用
    new(B).do()
}
```


17. 易读，函数禁止超过50行，如果过长应该考虑适当拆分
```
看过一个函数，300行参数还是interface，真好，我一块屏幕也就能看50行
```


18. 扩展性,任何有可能或者极大可能有扩展需求的接口应该考虑扩展性（设计模式的应用）
```
常见的就是三层if else应当状态模式替换\logger的处理策略（邮件告警、短信告警）起码要考虑到后续可能增加企业微信告警
```

19. 边界条件,接口编写应当考虑边界条件
```
比如包变量是一个Slice，追加变量时候注意内存
比如官方包errgroup的使用，如果是range添加并发任务的话考虑协程带来的损耗
```

20. 函数的命名除了见名之意，加上一些设计模式的关键字也可以提高可读性，比如将A对象适配为B对象adapter后缀
```
# 比如过滤器filter做后缀
func EmojiFilter()

# 比如拦截器
func TraceInterceptor()

# 比如装饰器
func (*water) sugarDecorator()
```

### 架构设计角度

1. 微服务之间解耦（mongodb/MySQL数据库层隔离、redis隔离(key业务划分/微服务之间隔离))
2. 禁止随意将其他微服务依赖的数据库写入到正在开发的微服务配置，业务数据访问走GRPC
3. 错误日志的错误信息严格按照标准(logger)
